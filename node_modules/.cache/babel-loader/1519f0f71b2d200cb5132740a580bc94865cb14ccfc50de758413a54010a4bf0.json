{"ast":null,"code":"import { __awaiter } from \"tslib\";\nimport { getContext, setContext } from \"../Global.js\";\nimport { OfflineContext } from \"./OfflineContext.js\";\nimport { ToneAudioBuffer } from \"./ToneAudioBuffer.js\";\nimport \"./Destination.js\";\nimport \"./Listener.js\";\n/**\n * Generate a buffer by rendering all of the Tone.js code within the callback using the OfflineAudioContext.\n * The OfflineAudioContext is capable of rendering much faster than real time in many cases.\n * The callback function also passes in an offline instance of {@link Context} which can be used\n * to schedule events along the Transport.\n * @param  callback  All Tone.js nodes which are created and scheduled within this callback are recorded into the output Buffer.\n * @param  duration     the amount of time to record for.\n * @return  The promise which is invoked with the ToneAudioBuffer of the recorded output.\n * @example\n * // render 2 seconds of the oscillator\n * Tone.Offline(() => {\n * \t// only nodes created in this callback will be recorded\n * \tconst oscillator = new Tone.Oscillator().toDestination().start(0);\n * }, 2).then((buffer) => {\n * \t// do something with the output buffer\n * \tconsole.log(buffer);\n * });\n * @example\n * // can also schedule events along the Transport\n * // using the passed in Offline Transport\n * Tone.Offline(({ transport }) => {\n * \tconst osc = new Tone.Oscillator().toDestination();\n * \ttransport.schedule(time => {\n * \t\tosc.start(time).stop(time + 0.1);\n * \t}, 1);\n * \t// make sure to start the transport\n * \ttransport.start(0.2);\n * }, 4).then((buffer) => {\n * \t// do something with the output buffer\n * \tconsole.log(buffer);\n * });\n * @category Core\n */\nexport function Offline(callback_1, duration_1) {\n  return __awaiter(this, arguments, void 0, function (callback, duration) {\n    let channels = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 2;\n    let sampleRate = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : getContext().sampleRate;\n    return function* () {\n      // set the OfflineAudioContext based on the current context\n      const originalContext = getContext();\n      const context = new OfflineContext(channels, duration, sampleRate);\n      setContext(context);\n      // invoke the callback/scheduling\n      yield callback(context);\n      // then render the audio\n      const bufferPromise = context.render();\n      // return the original AudioContext\n      setContext(originalContext);\n      // await the rendering\n      const buffer = yield bufferPromise;\n      // return the audio\n      return new ToneAudioBuffer(buffer);\n    }();\n  });\n}","map":{"version":3,"names":["getContext","setContext","OfflineContext","ToneAudioBuffer","Offline","callback_1","duration_1","callback","duration","channels","arguments","length","undefined","sampleRate","originalContext","context","bufferPromise","render","buffer"],"sources":["/Users/ayakos/Documents/GitHub/TapSound/node_modules/tone/Tone/core/context/Offline.ts"],"sourcesContent":["import { getContext, setContext } from \"../Global.js\";\nimport { Seconds } from \"../type/Units.js\";\nimport { OfflineContext } from \"./OfflineContext.js\";\nimport { ToneAudioBuffer } from \"./ToneAudioBuffer.js\";\nimport \"./Destination.js\";\nimport \"./Listener.js\";\n\n/**\n * Generate a buffer by rendering all of the Tone.js code within the callback using the OfflineAudioContext.\n * The OfflineAudioContext is capable of rendering much faster than real time in many cases.\n * The callback function also passes in an offline instance of {@link Context} which can be used\n * to schedule events along the Transport.\n * @param  callback  All Tone.js nodes which are created and scheduled within this callback are recorded into the output Buffer.\n * @param  duration     the amount of time to record for.\n * @return  The promise which is invoked with the ToneAudioBuffer of the recorded output.\n * @example\n * // render 2 seconds of the oscillator\n * Tone.Offline(() => {\n * \t// only nodes created in this callback will be recorded\n * \tconst oscillator = new Tone.Oscillator().toDestination().start(0);\n * }, 2).then((buffer) => {\n * \t// do something with the output buffer\n * \tconsole.log(buffer);\n * });\n * @example\n * // can also schedule events along the Transport\n * // using the passed in Offline Transport\n * Tone.Offline(({ transport }) => {\n * \tconst osc = new Tone.Oscillator().toDestination();\n * \ttransport.schedule(time => {\n * \t\tosc.start(time).stop(time + 0.1);\n * \t}, 1);\n * \t// make sure to start the transport\n * \ttransport.start(0.2);\n * }, 4).then((buffer) => {\n * \t// do something with the output buffer\n * \tconsole.log(buffer);\n * });\n * @category Core\n */\nexport async function Offline(\n\tcallback: (context: OfflineContext) => Promise<void> | void,\n\tduration: Seconds,\n\tchannels = 2,\n\tsampleRate: number = getContext().sampleRate\n): Promise<ToneAudioBuffer> {\n\t// set the OfflineAudioContext based on the current context\n\tconst originalContext = getContext();\n\n\tconst context = new OfflineContext(channels, duration, sampleRate);\n\tsetContext(context);\n\n\t// invoke the callback/scheduling\n\tawait callback(context);\n\n\t// then render the audio\n\tconst bufferPromise = context.render();\n\n\t// return the original AudioContext\n\tsetContext(originalContext);\n\n\t// await the rendering\n\tconst buffer = await bufferPromise;\n\n\t// return the audio\n\treturn new ToneAudioBuffer(buffer);\n}\n"],"mappings":";AAAA,SAASA,UAAU,EAAEC,UAAU,QAAQ,cAAc;AAErD,SAASC,cAAc,QAAQ,qBAAqB;AACpD,SAASC,eAAe,QAAQ,sBAAsB;AACtD,OAAO,kBAAkB;AACzB,OAAO,eAAe;AAEtB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAiCA,OAAM,SAAgBC,OAAOA,CAAAC,UAAA,EAAAC,UAAA;sDAC5BC,QAA2D,EAC3DC,QAAiB;IAAA,IACjBC,QAAQ,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,CAAC;IAAA,IACZG,UAAA,GAAAH,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAqBV,UAAU,EAAE,CAACa,UAAU;IAAA;MAE5C;MACA,MAAMC,eAAe,GAAGd,UAAU,EAAE;MAEpC,MAAMe,OAAO,GAAG,IAAIb,cAAc,CAACO,QAAQ,EAAED,QAAQ,EAAEK,UAAU,CAAC;MAClEZ,UAAU,CAACc,OAAO,CAAC;MAEnB;MACA,MAAMR,QAAQ,CAACQ,OAAO,CAAC;MAEvB;MACA,MAAMC,aAAa,GAAGD,OAAO,CAACE,MAAM,EAAE;MAEtC;MACAhB,UAAU,CAACa,eAAe,CAAC;MAE3B;MACA,MAAMI,MAAM,GAAG,MAAMF,aAAa;MAElC;MACA,OAAO,IAAIb,eAAe,CAACe,MAAM,CAAC;IACnC,CAAC;EAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}